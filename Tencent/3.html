<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta
			name="viewport"
			content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"
		/>

		<title>题目</title>
		<style>
			.container {
				width: 500px;
				height: 300px;
				overflow-y: auto;
				padding: 10px;
				background-color: #eee;
			}

			.container img {
				width: 400px;
				height: 200px;
				display: block;
				margin: 20px auto;
				border: 1px solid #eee;
				border-radius: 16px;
			}
		</style>
	</head>
	<body>
		<div>
			<div class="container">
				<img
					src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKAQMAAAC3/F3+AAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjwAsAAB4AAdpxxYoAAAAASUVORK5CYII="
					data-src="https://uploadfiles.nowcoder.com/images/20231219/644558031_1702977103756/40E5FD3EDDC8F069C403C44E8706A49D"
				/>
				<img
					src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKAQMAAAC3/F3+AAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjwAsAAB4AAdpxxYoAAAAASUVORK5CYII="
					data-src="https://uploadfiles.nowcoder.com/images/20231219/644558031_1702977108368/701BC31183B90F9B1EF8F6F547B15241"
				/>
				<img
					src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKAQMAAAC3/F3+AAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjwAsAAB4AAdpxxYoAAAAASUVORK5CYII="
					data-src="https://uploadfiles.nowcoder.com/images/20231219/644558031_1702977112183/BE1B361A179B334766CF4726D5C384FF"
				/>
				<img
					src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKAQMAAAC3/F3+AAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjwAsAAB4AAdpxxYoAAAAASUVORK5CYII="
					data-src="https://uploadfiles.nowcoder.com/images/20231219/644558031_1702977116090/BA59D92D87F1EB22700D4B61D575CD4C"
				/>
				<img
					src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKAQMAAAC3/F3+AAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjwAsAAB4AAdpxxYoAAAAASUVORK5CYII="
					data-src="https://uploadfiles.nowcoder.com/images/20231219/644558031_1702977119734/350FA018A370918FE50F54A89095CC31"
				/>
				<img
					src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKAQMAAAC3/F3+AAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjwAsAAB4AAdpxxYoAAAAASUVORK5CYII="
					data-src="https://uploadfiles.nowcoder.com/images/20231219/644558031_1702977123045/ECE3EFE60C9D5C5AC6BE5171AB094AD0"
				/>
				<img
					src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKAQMAAAC3/F3+AAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjwAsAAB4AAdpxxYoAAAAASUVORK5CYII="
					data-src="https://uploadfiles.nowcoder.com/images/20231219/644558031_1702977127519/EDC7425E5F8B6201E8576290F41E4BB7"
				/>
			</div>
		</div>

		<script>
			// 场景描述：图片懒加载是常见的前端性能优化手段之一，当图片进入可视区域时，再去加载图片资源，可以有效减少不必要的网络请求。Chrome 和 Firefox 都支持使用添加 loading="lazy" 属性的延迟加载。但是该方案不支持加载中情况下的占位图、设置视口距离阈值等。所以IntersectionObserver 接口（从属于 Intersection Observer API）提供了一种异步观察目标元素与其祖先元素或顶级文档视口 （viewport） 交叉状态的方法，来实现图片的懒加载。效果如下图：
			// 代码实现：补全代码实现当图片出现在 .container 的可视区，将图片的src属性值替换成data-src属性值。
			// 下面给出 IntersectionObserver 用法提示：
			//  `IntersectionObserver`  是一个用于监听元素与其祖先或视口交叉状态的 API。它提供了一种有效的方式来观察元素是否进入或离开视口，或者与其祖先元素交叉。下面是  `IntersectionObserver`  类的基本用法：
			// 1. 创建  `IntersectionObserver`  实例：
			//    const observer = new IntersectionObserver(callback, options);
			//    - `callback` 是一个回调函数，用于处理元素与交叉目标的交叉变化。
			//    - `options` 是一个配置对象，用于指定观察器的选项，例如 `root`（根元素），`rootMargin`（根边距），`threshold`（阈值）等。
			// 2. 使用  `observe()`  方法开始观察一个目标元素：
			//    observer.observe(target);
			//    - `target` 是要观察的目标元素。
			// 3. 在回调函数中处理交叉变化：
			//    const callback = (entries, observer) => {
			//      entries.forEach(entry => {
			//        // 处理交叉变化
			//        if (entry.isIntersecting) {
			//          // 元素进入视口或与祖先元素交叉
			//        } else {
			//          // 元素离开视口或不再与祖先元素交叉
			//        }
			//      });
			//    };
			//    - `entries` 是一个  `IntersectionObserverEntry`  对象数组，包含了每个目标元素的交叉信息。
			//    - `entry.isIntersecting`  表示目标元素是否与交叉目标发生交叉。
			// 4. 停止观察一个目标元素：
			//    observer.unobserve(target);
			//    - `target` 是要停止观察的目标元素。
			const images = document.querySelectorAll(".container img");
			lazy(images);

			function lazy(el) {
				let els = Array.isArray(el) || el.length ? [...el] : [el];
				const io = new IntersectionObserver((entries) => {
					entries.forEach((entry) => {
						// 补全代码：判断当前监听的元素是否在视口范围，在视口范围找到该元素，并改变img的src属性值，同时将该元素从监听中删除。不在视口范围不做任何处理。
						if (entry.isIntersecting) {
							entry.target.src = entry.target.dataset.src;
						}
					});
				});
				els.forEach((el) => io.observe(el));
				return cancel;

				function cancel(el) {
					if (!io) return;
					if (el) return io.unobserve(el);
					els.forEach((el) => io.unobserve(el));
					io.disconnect();
				}
			}
		</script>
	</body>
</html>
